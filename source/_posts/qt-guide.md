---
title: Qt 入门笔记
date: 2020-02-21 20:26:59
tags: 工具


---

出于某些原因，在寒假接触了 [Qt](https://www.qt.io/) ，和此前接触过的 MFC 一样，Qt 也是一个应用于 GUI 开发的跨平台 C++ 开发框架，通过语言绑定，也可以使用其他编程语言进行开发，而且它是开源的。Qt 的开发工具一般为 [Qt Creator](https://www.qt.io/product) ，也可以在带设置的文本编辑器（如 VSCode）中指定编译源进行开发。

<!-- more -->

## 实现 UI 的方式

从本质上来说，Qt 是一个第三方库，其中含有了展示 UI 的部分。如果用户要编写一个具有 UI 的程序，就必须要调用库中的组件（`QWidget`）（Qt 中的头文件一般都以大写的 Q 开头），通过 `show()` 和 `hide()` 方法就能实现组件的显示和隐藏，此外不同的组件也有其特有的方法。

而实现 UI 的代码风格主要有三种（即是 Qt Creator 中支持的三种）：

- 命名空间（指针）风格

  首先你如果要创建一个组件的类，不妨说是一个窗口（不妨类名叫做 `MyWindow`），那么你可以新建一个名为 `mywindow.h` 的头文件，引入 `<QMainWindow>` ，使 `MyWindow` 类继承自 `QMainWindow` 类；同时你需要一个名为 `Ui` 的命名空间，里面声明了一个也叫 `MyWindow` 的类，它的一个指针实例 `ui` 是你定义的 `MyWindow` 类的一个私有成员变量。

  新 `MyWindow` 类会在另一个头文件 `ui_mywindow.h` 的 `Ui` 命名空间中进行定义。它继承自 `Ui_MyWindow` ，一个新定义的类，里面的成员变量包含这个窗口中的组件，比如按钮（`QPushButton`）、布局（如 `QGridLayout`）等。此外这个类还有两个方法，`void setupUi(QMainWindow*);` 和 `void retranslateUi(QMainWindow*);` ，它们分别用于初始化窗口的组件和翻译窗口中的内容（这一方面是 Qt 国际化的需要，可以通过翻译文件的引入让 Qt 支持多国语言）。那么在 `MyWindow` 类的构造函数中你只需要初始化 `ui` 然后调用 `ui->setupUi(this);` 即可完成组件的初始化。

  至于为什么这么做，是因为 Qt 提供了一种通过拖曳来自由地设计组件的方式，这些信息会保存在一个 `.ui` 文件中（本质上是一个 `.xml` ），然后编译时自动生成 `ui_mywindow.h` ，为设计 UI 带来了很大的便利。

- 多继承风格

  这一种代码风格和上一种使用相同的 `ui_xxx.h` 文件，但是不再使用命名空间，而是多继承，即同时继承自 `QMainWindow` 和 `ui_xxx.h` 中的 `Ui::MyWindow` （这一点是完全可行的，因为 Qt 中所有的对象都继承自基类 `QObject`）。那么在初始化的时候就不是 `ui->setupUi(this);` 而是直接 `setupUi(this);` 。这一种方法的优点是，它可以让多个头文件共享页面设计（也就是 `.ui` 文件）。

- 命名空间（非指针）风格

  和第一种基本类似，只不过 `ui` 不再是指针。

## 信号和槽机制

这是 Qt 中很重要的内容，它完美地体现了高内聚低耦合的设计理念。感性地来说，就是对于任意一个对象，它都有两种行为：接收信号、发出信号。至于接收到的信号是谁发出的，信号要发送给谁，这都不需要考虑。信号是一个函数，在使用时，只需要通过 `connect` 将发送方的发送函数和接收方的接收函数（通常称为槽函数）联系起来即可，不需要联系了也可以 `disconnect` 。此外，一个对象可以和任意多个对象之间进行联系。联系的内容都放在信号函数和槽函数的参数中，因此这两种函数一般都没有返回值。

比如，我有两个指针对象，分别是 `m_sender` 和 `m_receiver` ，什么类型的无所谓。其中 `m_sender` 的发送函数加入叫 `void sendData(bool, QString);` ，它是不需要做任何定义的，因为它只是一个信号，内容都放在参数中，在这里即是一个布尔值和一个 Qt 的字符串，发送信号的方式为 `emit sendData(..., ...);` 。那么接收方，`m_receiver` ，就需要定义一个槽函数 `void receiveData(bool, QString);` 来进行接收，它内部所进行的操作即为接收到信号以后需要做的操作，比如输出、弹框、存储，等等。当然，在此之前需要 `connect` 。

对于 `connect` 操作，也有不同的写法。旧式的风格是使用宏定义：

```c++
connect(m_sender, SIGNAL(sendData(bool, QString)),
        m_receiver, SLOT(receiveData(bool, QString)));
```

而现在则可以这么写：

```c++
connect(m_sender, &M_Sender::sendData, m_receiver, &M_Receiver::receiveData);
```

其中 `M_Sender` 和 `M_Receiver` 都是类名。这一写法可以很好地避免若参数不统一可能带来的错误。此外对于比较简单的接收函数，还可以写成 lambda 表达式的形式来优化代码。举一个例子，比如我们要实现一个按钮 `btn` 的点击（`click`）反馈机制，那么本质上来说就是设计一个函数来接收 `btn` 发出的 `clicked` 信号，Qt 会自动绑定 `on_btn_clicked` 函数为它的槽函数，如果你编写了这样的同名函数的话。但如果你要做的事情比较简单，则可以直接写为：

```c++
connect(ui->btn, &QPushButton::clicked, [&]{/* do something */});
```

把这个写在构造函数中，可以省去很多函数的定义，且看上去一目了然。

至于 Qt 内部是怎么实现如此精妙的设计的，不知道，无可奉告。

## 翻译文件

前文讲到，为了实现 Qt 国际化，Qt 支持使用翻译文件。通过 `lupdate` 命令，会将代码中用 `tr()` 函数包裹的字符串都提取出来，生成 `.ts` 文件（本质上也是一个 `.xml`），然后通过 `linguist` 命令打开翻译工具，手动或自动地将对应字符串翻译成另一种语言（一个 `.ts` 文件对应一种语言），最后通过 `lrelease` 命令将 `.ts` 文件转化成 `.qm` 文件，即可在程序中通过 `load` 的方式使用翻译文件了。